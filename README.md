# DistributedFileServer
1. 基于Golang实现的一个分布式文件上传服务
2. 重点结合开源存储(Ceph)以及公有云(阿里OSS)支持断点续传以及秒传功能。
3. 微服务化以及容器化部署，从而实现一个分布式文件的存储服务。


## 自己下去要做的一些事情：
1. 了解私有云，公有云，容器编排的概念
2. 

## 预期收获
1. redis/rabbidMq：实现将服务模块中的同步逻辑转换成异步来执行，结合进行业务开发
2. docker/kubernets(一个容器编排工具)
3. 分布式对象存储(Ceph)
4. 阿里云OSS对象存储服务

## 收货哪些干活
1. 将会熟悉文件分块断点上传以及秒传的概念
2. 文件对象从私有云迁移到公有云的经验，从cephq迁移到阿里云的OSS的经验


## 课程安排
1. 2-6章：构建一个基础版的文件上传服务，基本功能可以使用，例如文件上传下载，但是性能架构方面自己还是需要进行升级和优化
2. 7-11章：架构逐步升级，搭建一个完整优化的分布式服务
3. 12章：课程总结

## 自己的建议：
1. 如果到时候看完了想要写到简历上，自己可以回头看第一章里面有讲具体过程，
2. 老师的接口并没有遵循restful接口，自己做完这个项目可以尝试自己改进，使用restful接口来实现，如果有机会可以通过graphQL来实现这个
3. 自己可以通过vue来实现页面，将内容更加丰富
4. 更合理的是在文件上传保存之后，在下载那一端部署一个反向代理，然后将文件作为一个静态资源来处理，例如nginx，下载的时候后端服务会提供一个接口，用于构造下载文件的url，客户端获取url之后，就去下载，下载的时候会经过nginx，
nginx再做一次静态资源访问将文件download下来，一些限流以及权限访问都可以在nginx做，可以减轻golang实现后端的压力。
5. 自己觉得我们定义的文件元信息，没有给json对应序列化加上一个tag，以为golang中属性字母都是大写开头为了其他包可以访问，因此自己觉得最好在对应的字段后面加上一个json的tag



自己在第2章内容上可以做的：

1. 因为上传同一个文件，sha1值都是根据上传文件的内容生成，所以不同用户上传同一文件但是上传时的文件名如何处理？比如A,B都上传同一个文件，但是A上传的时候叫做a.txt而B上传的时候叫做b.txt
2. 另外一个是不同用户上传同一个文件，但是我们如果使用计算sha1并更新，将会不断重新上传，我们其实可以判断sha1是否已经存在，避免不必要的上传，来节省带宽。
3. 自己在用户查询最近上传文件的时候做了判断，因为用户需要传入一个limit参数表示查最近上传的几个，所以如果文件总数小于limit的时候，直接切片切[0:limit]将会越界panic。



## 最初的文件系统（第2章完成之后实现的效果）

架构如图所示：
![Y5wuE2](https://gitee.com/yirufeng/images/raw/master/uPic/Y5wuE2.png)

## 接口列表

![JomueR](https://gitee.com/yirufeng/images/raw/master/uPic/JomueR.png)



获取文件的信息：http://localhost:8080/file/meta?filehash=上传文件的sha1哈希值



## 第2章：步骤


### 文件上传
2-1，2-2做的内容：
1. 项目根目录下新建一个main.go以及handler文件夹同时在handler文件夹下新建一个handler.go文件(专门用于处理上传的接口)
2. 项目根目录下新建一个static文件夹用于存放静态资源文件，同时新建一个view文件夹，用于存储对应的html文件
3. 在handler.go下我们自己实现了一个文件上传函数，同时在上传成功后我们重定向到一个文件上传成功的处理函数中

2-3的内容：
不是文件上传上去就完成了，有时候我们要去查询，如何做呢？
就是把每次上传文件的内容记录下来，例如文件的哈希md5以及sha1作为文件的id，上传时间，文件名，文件大小，文件存储路径，这些内容都要保留下来，便于查询接口返回给用户
上面这些内容我们都封装到了util.go 老师已经写好的，直接用就可以了
1. 新建一个文件夹util同时将老师的util.go放进去
2. 新建文件夹meta，同时新建filemeta.go用来存储文件元信息，
        同时我们在这个里面新建了一个全局变量(采用键值对，键为文件的sha1，值就是对应的文件元信息结构体)用来存储所有上传文件的元信息，
        我们新增了两个方法一个是用来增加或者更新文件的元信息，另外一个是获取文件的元信息
3. 修改我们之前的处理文件上传逻辑，在上传之前新建一个文件元结构体，并且同时更新之前的处理文件上传逻辑。
    3.1 新建一个文件的结构体
    3.2 文件结构体的FileSize字段为io.Copy(newFile, file)返回的第1个结果，也就是已经写入的字节长度
    3.3 之后我们需要获取文件的sha1，但是获取之间，我们需要将newFile也就是我们写入到目的地的文件句柄在刚才写完之后，我们要将其重新移动到最开始的位置来计算sha1，之后我们就可以给文件结构体的sha1进行赋值
    3.4 这时我们可以进行上传文件元结构信息的操作(也就是将文件映射到我们前面定义的map中便于查询)

文件上传演示总结：

![R1QW2Q](https://gitee.com/yirufeng/images/raw/master/uPic/R1QW2Q.png)
真正的生产环境中会保存在redis或mysql中


### 文件元信息查询

2-4 文件元信息查询接口：
原理：通过文件的hash值来查询，

实现的功能：
1. 单个查询（通过指定的hash值来查询）
2. 批量查询（例如，最近上传的文件对应的信息）


1. 首先编写一个获取文件元信息的处理函数，从表单中获取文件的hash值，之后去我们定义的方法中根据对应的hash值查询对应的文件元信息，将文件元信息序列化后返回给用户
2. 将该函数添加到main函数中的映射中
3. 通过命令`sha1sum 刚才上传的文件`直接获取对应文件的sha1值，
4. 启动运行之后，发现通过`http://localhost:8080/file/meta/?filehash=刚才上传文件的hash`可以获取到我们序列化后的json文件元信息


自己百度的资料：
1. `sha1sum命令补充：`sha1sum命令用于生成和校验文件的sha1值。它会逐位对文件的内容进行校验。是文件的内容，与文件名无关，也就是文件内容相同，其sha1值相同。[参考](https://www.linux265.com/course/5071.html)

### 文件下载接口
原理：根据用户提供的filehash值来将文件对应的内容返回给用户。
更合理的是在文件上传保存之后，在下载那一端部署一个反向代理，然后将文件作为一个静态资源来处理，例如nginx，下载的时候后端服务会提供一个接口，用于构造下载文件的url，客户端获取url之后，就去下载，下载的时候会经过nginx，
nginx再做一次静态资源访问将文件download下来，一些限流以及权限访问都可以在nginx做，可以减轻golang实现后端的压力。


思路：服务端通过文件元信息的位置读取文件到内存然后返回给客户端
1. 首先解析用户请求中携带的filehash值，
2. 根据我们自己写的方法从map中查询到文件元信息之后，就可以获取到文件存储的位置
3. 之后打开文件，将其读到内存，然后将数据写入到给用户返回的响应中
4. 其实前3步我们就已经做完了下载，但是为了让浏览器有一个下载文件的效果，我们又在返回的响应头部加入两个字段，使得浏览器有一个下载文件的效果
5. 启动运行之后，发现通过`http://localhost:8080/file/download?filehash=刚才上传文件的hash`便可以通过浏览器下载获取的文件

### 文件Meta更新(重命名)接口

#### 修改文件元信息，以文件重命名为例

需要用户上传两个值，一个是sha1(文件唯一的哈希值)，另外一个是重命名后的文件名

步骤：
1. 解析用户请求的参数列表，用户携带3个参数，1个操作类型，1个文件的唯一标识，1个更新后的文件名
2. 根据用户请求的参数列表获取用户的操作类型，(如果操作类型不是0，那么代表其他操作，我们就返回一个403)
3. 如果用户请求的类型不是post，直接返回一个405
4. 获取用户请求中携带的文件唯一标识，直接修改文件元信息map集合中的文件名为更新后的文件名即可
5. 将修改后的文件元信息序列化返回给用户


### 文件删除接口
主要是实现两个删除操作
1. 删除索引数据，也就是从我们的map中删除
2. 删除文件系统中的数据，也就是物理删除

步骤：
1. 解析用户请求的参数
2. 获取用户请求中的文件filesha1。
3. 根据文件的fielsha1获取文件对应的元信息中的文件存储路径，进行删除
3. 从存储文件元信息的map集合删除文件对应的键值对
4. 返回给用户操作成功

注意：目前所有文件所有元信息都存储在内存中，所以一旦重启所有元信息都没了，在真正的生产环境中我们存放到redis或者mysql数据库，便于增删改查以及安全性。



这个是存放在meta下的filemeta.go文件中，老师视频中没有讲到：

### 有一个视频这里没有，关于文件信息查询，url中使用了query

1. 首先在meta下面新建一个sort.go，按照上传时间排序
2. 之后再fileMeta.go中编写一个获取批量文件元信息列表的方法![48YP7u](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/48YP7u.png)
3. 编写对应的handler处理函数FileQueryHandler, 解析用户请求的参数，获取用户传入的参数limit,表示查最近上传的几个文件，之后调取我们meta中编写的方法，新建一个存储文件元信息的切片，同时根据最近上传时间查询之后添加到切片中并序列化后返回
4. 最后在main.go中映射对应的url以及handler处理函数


### 本章小结
![ZbUE8T](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/ZbUE8T.png)


## v1文档列表

> v1表示已经搭建好的最初文件系统，只实现了文件上传，下载，重命名，删除，以及查询最近上传文件的功能。

接口：

1. 上传文件：到http://localhost:8080/file/upload传入要上传的文件
2. 查询上传文件的元信息(get)：http://localhost:8080/file/meta?filehash=文件的sha1值
3. 查询最近上传的几个文件(get)：http://localhost:8080/file/query/?limit=一个值
4. 文件修改(post)(只是修改了map中的映射文件名，实际上物理存储的文件名没修改)：http://localhost:8080/file/update?op=0&filehash=文件的sha1值&filename=新文件名(如111.png)
5. 文件删除(get)：http://localhost:8080/file/delete?filehash=文件sha1值
6. 文件下载(get)：http://localhost:8080/file/download?filehash=文件sha1值